#include"osp.h"
#include"client.h"

#define MAKEESTATE(state,event) ((u32)((event) << 4 + (state)))
#define CLIENT_APP_SUM           5
#define APP_NUM_SIZE             20

#define SERVER_DELAY             1000
#define CREATE_TCP_NODE_TIMES     20

#if 0
#define MAX_CMD_REPEAT_TIMES     5
#endif

API void Connect2Server();
API int SendSignInCmd();
API int SendSignOutCmd();
API void SendFileUploadCmd();
API void MultSendFileUploadCmd();
API void SendCancelCmd();
API void SendRemoveCmd();
API void SendFileGoOnCmd();
API void Disconnect2Server();

static void UploadCmdSingle(const s8*);

static u32 g_dwdstNode;
#if SINGLE_APP
bool        g_bConnectedFlag;    
bool        g_bSignFlag;         
#endif


#if MULTY_APP
static CCApp *g_cCApp[CLIENT_APP_SUM];
#else
static CCApp g_cCApp;
#endif

static u16 g_wTestSingleAppId;


int main(){

#ifdef _MSC_VER
        int ret = OspInit(TRUE,2501,"WindowsOspClient");
#else
        int ret = OspInit(TRUE,2501,"LinuxOspClient");
#endif
        s16 i,j;
        s8 chAppNum[APP_NUM_SIZE];
        bool bCreateTcpNodeFlag = false;

#if SINGLE_APP
        g_bConnectedFlag = false;
        g_bSignFlag      = false;
#endif

        if(!ret){
                OspPrintf(1,0,"osp init fail\n");
        }

        printf("demo client osp\n");
#if MULTY_APP
        for(i = 0;i < CLIENT_APP_SUM;i++ ){
                g_cCApp[i] = new CCApp();
#if 0
                //涉及到线程安全，不使用malloc
                g_cCApp[i] = (CCApp*)malloc(sizeof(CCApp));
#endif
                if(!g_cCApp[i]){
                        OspLog(LOG_LVL_ERROR,"[main]app malloc error\n");
                        printf("[main]app malloc error\n");
                        OspQuit();
                        for(j = 0;j < i;j++){
                                delete(g_cCApp[j]);
                        }
                        return -1;
                }
                if(OSP_OK != g_cCApp[i]->CreateApp("OspClientApp"+sprintf(chAppNum,"%d",i)
                                ,CLIENT_APP_ID+i,CLIENT_APP_PRI,MAX_MSG_WAITING)){

                        OspLog(LOG_LVL_ERROR,"[main]app create error\n");
                        return -1;
                }
        }
#else
        if(OSP_OK != g_cCApp.CreateApp("OspClientApp",CLIENT_APP_ID,CLIENT_APP_PRI,MAX_MSG_WAITING)){
                OspLog(LOG_LVL_ERROR,"[main]app create error\n");
                return -1;
        }
#endif

#if 1
        //尝试多次建立node，支持本地多个客户端的副本
        for(i = 0;i < CREATE_TCP_NODE_TIMES;i++){
                if(INVALID_SOCKET != (ret = OspCreateTcpNode(0,OSP_AGENT_CLIENT_PORT+i*3))){
                        bCreateTcpNodeFlag = true;
                        break;
                }
        }
        if(!bCreateTcpNodeFlag){
                OspQuit();
#if MULTY_APP
                for(i = 0;i < CLIENT_APP_SUM;i++ ){
                        delete(g_cCApp[i]);
                }
#endif
                OspPrintf(1,0,"[main]create positive node failed,quit\n");
                printf("[main]node created failed\n");
                return -1;
        }
#else
        ret = OspCreateTcpNode(0,OSP_AGENT_CLIENT_PORT);
        if(INVALID_SOCKET == ret){
                OspQuit();
                for(i = 0;i < CLIENT_APP_SUM;i++ ){
                        delete(g_cCApp[i]);
                }
                OspPrintf(1,0,"[main]create positive node failed,quit\n");
                printf("[main]node created failed\n");
                return -1;
        }
#endif

#ifdef _LINUX_
        OspRegCommand("Connect",(void*)Connect2Server,"");
        OspRegCommand("DisConnect",(void*)Disconnect2Server,"");
        OspRegCommand("SignIn",(void*)SendSignInCmd,"");
        OspRegCommand("SignOut",(void*)SendSignOutCmd,"");
        OspRegCommand("FileUpload",(void*)SendFileUploadCmd,"");
        OspRegCommand("MFileUpload",(void*)MultSendFileUploadCmd,"");
        OspRegCommand("Cancel",(void*)SendCancelCmd,"");
        OspRegCommand("Remove",(void*)SendRemoveCmd,"");
        OspRegCommand("GoOn",(void*)SendFileGoOnCmd,"");
#endif
        //TODO:连接参数可选配置
        g_dwdstNode = OspConnectTcpNode(inet_addr(SERVER_IP),SERVER_PORT,10,3);
        if(INVALID_NODE == g_dwdstNode){
                OspLog(SYS_LOG_LEVEL, "[main]Connect to server faild.\n");
#if 0
                //尝试再次连接由sign in 执行
                //TODO:提供连接参数输入，尝试再次连接
                scanf("ip:%d port:%d\n",server_ip,server_port);
                g_dwdstNode = OspConnectTcpNode(inet_addr(SERVER_IP),SERVER_PORT,10,3);
                if(INVALID_NODE == g_dwdstNode){
                        OspLog(SYS_LOG_LEVEL, "[main]Connect to server faild again.\n");
                }
#endif
        }else{
                OspLog(SYS_LOG_LEVEL, "[main]Connect to server successfully.\n");
#if MULTY_APP
                for(i = 0;i < CLIENT_APP_SUM;i++){
                        //断链注册
                        if(OSP_OK !=OspNodeDiscCBRegQ(g_dwdstNode,i+CLIENT_APP_ID,CInstance::DAEMON)){
                            OspLog(LOG_LVL_ERROR,"[main]regis disconnect error\n");
                            return -1;
                        }
                        //通知连接
                        if(OSP_OK != ::OspPost(MAKEIID(i+CLIENT_APP_ID,CInstance::DAEMON),MY_CONNECT,
                                        NULL,0)){
                               OspLog(LOG_LVL_ERROR,"[Connecte2Server] post error\n");
                               //TODO:错误处理方式
                               return -1;
                        }
                }
#else
                //断链注册
                if(OSP_OK !=OspNodeDiscCBRegQ(g_dwdstNode,CLIENT_APP_ID,CInstance::DAEMON)){
                    OspLog(LOG_LVL_ERROR,"[main]regis disconnect error\n");
                    return -1;
                }

                g_bConnectedFlag = true;
#endif
        }
        while(1)
                OspDelay(100);

        OspQuit();
#if MULTY_APP
        for(i = 0;i < CLIENT_APP_SUM;i++ ){
                delete(g_cCApp[i]);
        }
#endif
        return 0;
}

API void Test_Sign(){

#if 0
        assert(0 == SendSignInCmd());
        assert(0 == SendSignOutCmd());

        SendSignInCmd();
        SendSignInCmd();
#endif
}

API void Connect2Server(){

        u16 i;

        g_dwdstNode = OspConnectTcpNode(inet_addr(SERVER_IP),SERVER_PORT,10,3);
        if(INVALID_NODE == g_dwdstNode){
                OspLog(LOG_LVL_KEY, "Connect extern node failed. exit.\n");
                return;
        }

#if MULTY_APP
        //断链注册
        for(i = 0;i < CLIENT_APP_SUM;i++){
                //断链注册
                if(OSP_OK !=OspNodeDiscCBRegQ(g_dwdstNode,i+CLIENT_APP_ID,CInstance::DAEMON)){
                    OspLog(LOG_LVL_ERROR,"[main]regis disconnect error\n");
                    return;
                }
                //通知连接
                if(OSP_OK != ::OspPost(MAKEIID(i+CLIENT_APP_ID,CInstance::DAEMON),MY_CONNECT,
                                NULL,0)){
                       OspLog(LOG_LVL_ERROR,"[Connecte2Server] post error\n");
                       //TODO:错误处理方式
                    return;
                }
        }
#else
        //断链注册
        if(OSP_OK !=OspNodeDiscCBRegQ(g_dwdstNode,CLIENT_APP_ID,CInstance::DAEMON)){
            OspLog(LOG_LVL_ERROR,"[main]regis disconnect error\n");
            return -1;
        }

        g_bSignFlag = true;
#endif

}

API void Disconnect2Server(){

        if(!OspDisconnectTcpNode(g_dwdstNode)){
                OspLog(LOG_LVL_ERROR,"[Disconnect2Server]disconnecte failed\n");
                return;
        }
}

API void SendFileGoOnCmd(){


        if(OSP_OK != ::OspPost(MAKEIID(g_wTestSingleAppId,CLIENT_INSTANCE_ID),FILE_GO_ON_CMD,
                        NULL,0)){
               OspLog(LOG_LVL_ERROR,"[SendFileGoOnCmd] post error\n");
        }
}

API void SendCancelCmd(){


       if(OSP_OK != ::OspPost(MAKEIID(g_wTestSingleAppId,CLIENT_INSTANCE_ID),SEND_CANCEL_CMD,
                        NULL,0)){
               OspLog(LOG_LVL_ERROR,"[SendCancel] post error\n");
       }
}

API void SendRemoveCmd(){

        if(OSP_OK != ::OspPost(MAKEIID(g_wTestSingleAppId,CLIENT_INSTANCE_ID),SEND_REMOVE_CMD,
                        NULL,0)){
               OspLog(LOG_LVL_ERROR,"[SendRemoveCmd] post error\n");
        }
}

#if MULTY_APP
API int SendSignInCmd(){

        TSinInfo tSinInfo;

        //查询所有app instance，找到空闲的instance来执行sign in操作
        u16 i,wAppId;
        bool bPendingFlag = false;
        CCInstance *ccIns;

        strcpy(tSinInfo.Username,"Robert");
        strcpy(tSinInfo.Passwd,"admin");

        for(i = 0;i < CLIENT_APP_SUM;i++){
                ccIns = (CCInstance*)((CApp*)g_cCApp[i])->GetInstance(CLIENT_INSTANCE_ID);
                if(!ccIns){
                        OspLog(LOG_LVL_ERROR,"[SendSignInCmd] can not find client instance\n");
                        printf("[SendSignInCmd] can not find client instance\n");
                        return -1;
                }
                wAppId = ccIns->GetAppID();
                if(ccIns->CurState() == CInstance::PENDING){
                        bPendingFlag = true;
                        break;
                }
        }
        if(!bPendingFlag){
                OspLog(LOG_LVL_ERROR,"[SendSignInCmd] max file uploaded arrived\n");
                return -2;
        }

        if(OSP_OK != ::OspPost(MAKEIID(wAppId,CInstance::DAEMON),SIGN_IN_CMD,
                        &tSinInfo,sizeof(tSinInfo))){
               OspLog(LOG_LVL_ERROR,"[SendSignInCmd] post error\n");
               return -3;
        }
        OspDelay(500);
        return 0;
}

#else
API void SendSignInCmd(){

        TSinInfo tSinInfo;

        strcpy(tSinInfo.Username,"Robert");
        strcpy(tSinInfo.Passwd,"admin");

        if(OSP_OK != ::OspPost(MAKEIID(wAppId,CInstance::DAEMON),SIGN_IN_CMD,
                        &tSinInfo,sizeof(tSinInfo))){
               OspLog(LOG_LVL_ERROR,"[SendSignInCmd] post error\n");
               return -3;
        }

}
#endif


API int SendSignOutCmd(){

        if(OSP_OK != ::OspPost(MAKEIID(CLIENT_APP_ID,CInstance::DAEMON),SIGN_OUT_CMD)){
               OspLog(LOG_LVL_ERROR,"[SendSignOutCmd] post error\n");
        }
}

static CCInstance* GetPendingInstance(u16 insId,CCApp *ccApp[],u16 appNum){

        u16 i;
        bool bPendingFlag = false;
        CCInstance *ccIns;

        for(i = 0;i < appNum;i++){
                ccIns = (CCInstance*)((CApp*)ccApp[i])->GetInstance(insId);
                if(!ccIns){
                        return NULL;
                }
                if(ccIns->CurState() == CInstance::PENDING){
                        bPendingFlag = true;
                        break;
                }
        }
        if(!bPendingFlag){
                return NULL;
        }
        return ccIns;
}

#if MULTY_APP
static void UploadCmdSingle(const s8* filename){

        CCInstance *ccIns;

        ccIns = GetPendingInstance(CLIENT_INSTANCE_ID,g_cCApp,CLIENT_APP_SUM);
        if(!ccIns){
                OspLog(LOG_LVL_ERROR,"[UploadCmdSingle] can not find client instance\n");
                printf("[UploadCmdSingle] can not find client instance\n");
                return;
        }
        g_wTestSingleAppId = ccIns->GetAppID();
        OspPrintf(1,0,"appid:%d\n",g_wTestSingleAppId);
        if(OSP_OK !=::OspPost(MAKEIID(ccIns->GetAppID(),CLIENT_INSTANCE_ID),FILE_UPLOAD_CMD,
                        filename,strlen(filename)+1)){
               OspLog(LOG_LVL_ERROR,"[UploadCmdSingle] post error\n");
        }
}
#else

static void UploadCmdSingle(const s8* filename){

        if(OSP_OK !=::OspPost(MAKEIID(CLIENT_APP_ID,CInstance::PENDING),FILE_UPLOAD_CMD,
                        filename,strlen(filename)+1)){
               OspLog(LOG_LVL_ERROR,"[UploadCmdSingle] post error\n");
        }

}
#endif

API void SendFileUploadCmd(){

        UploadCmdSingle("mydoc.7z");
}

API void MultSendFileUploadCmd(){

#if 1
        UploadCmdSingle("mydoc.7z");
        OspDelay(200);
        UploadCmdSingle("test_file_name");
#else
        ::OspPost(MAKEIID(3,CLIENT_INSTANCE_ID),FILE_UPLOAD_CMD,
                        "mydoc.7z",strlen("mydoc.7z")+1);
       ::OspPost(MAKEIID(4,CLIENT_INSTANCE_ID),FILE_UPLOAD_CMD,
                        "mydoc.7z",strlen("mydoc.7z")+1);
#endif
}

void CCInstance::FileUploadCmd(CMessage*const pMsg){

        //连接和登陆状态由广播获得，若间隔太小则可能发生错误，调用的时候需要确保
#if 0
        if(!m_bConnectedFlag){
                OspLog(LOG_LVL_ERROR,"[InstanceEntry]disconnected\n");
                return;
        }
#endif
        if(!m_bSignFlag){
                OspLog(SYS_LOG_LEVEL,"[FileUploadCmd]did not sign in\n");
                return;
        }

        //未处理完状态，重新放入消息队列等待状态稳定
        if(emFileStatus >= STATUS_SEND_UPLOAD&&
                        emFileStatus <= STATUS_RECEIVE_REMOVE){
                if(OSP_OK != post(MAKEIID(GetAppID(),GetInsID()),SEND_REMOVE_CMD
                               ,NULL,0)){
                        OspLog(LOG_LVL_ERROR,"[FileUploadCmd] post error\n");
                }
                return;
        }

        if(emFileStatus == STATUS_UPLOADING){
                OspLog(SYS_LOG_LEVEL, "[FileUploadCmd]Uploading...\n");
                return;
        }

        if(emFileStatus == STATUS_CANCELLED){
                OspLog(SYS_LOG_LEVEL, "[FileUploadCmd]File Cancelled,please use GoOn\n");
                return;
        }

        if(!pMsg->content || pMsg->length <= 0){
                 OspLog(LOG_LVL_ERROR,"[FileUploadCmd] pMsg is NULL\n");
                 OspPrintf(1,0,"[FileUploadCmd] pMsg is NULL\n");
                 printf("pmsg is null\n");
                 return;
        }

        strcpy((LPSTR)file_name_path,(LPCSTR)pMsg->content);
        
        if(!(file = fopen((LPCSTR)file_name_path,"rb"))){
                OspLog(LOG_LVL_ERROR,"[FileUploadCmd]open file failed\n");
                printf("[FileUploadCmd]open file failed\n");
                return;
        }
        //获取文件大小，根据标准c，二进制流SEEK_END没有严格得到支持，ftell返回值为long int，
        //32位系统大小限制在2G
        if(fseek(file,0L,SEEK_END) != 0){
                 OspLog(LOG_LVL_ERROR,"[FileUploadCmd] file fseeek error\n");
                 return;
        }
        if(-1L == (m_wFileSize = ftell(file))){
                 OspLog(LOG_LVL_ERROR,"[FileUploadCmd] file ftell error\n");
                 perror("file ftell error\n");
                 return;
        }
        rewind(file);

        if(OSP_OK != post(MAKEIID(SERVER_APP_ID,CInstance::DAEMON),FILE_SEND_UPLOAD
                       ,pMsg->content,pMsg->length,g_dwdstNode)){
                OspLog(LOG_LVL_ERROR,"[FileUploadCmd] post error\n");
                return;
        }
        NextState(RUNNING_STATE);
        emFileStatus = STATUS_SEND_UPLOAD;
}

void CCInstance::SignInCmd(CMessage *const pMsg){


#if MULTY_APP
        if(!m_bConnectedFlag){
#else
        if(!g_bConnectedFlag){
#endif

#if 0
                //TODO:注册函数改为有返回值的，重新连接部分改为调用执行
                scanf("ip:%s port:%d\n",server_ip,server_port);
                g_dwdstNode = OspConnectTcpNode(inet_addr(SERVER_IP),SERVER_PORT,10,3);
                if(INVALID_NODE == g_dwdstNode){
                        OspLog(LOG_LVL_ERROR, "[SignInCmd]Connect to server faild.\n");
                        return;
                }else{
                        m_bConnectedFlag = true;
                }
#endif
                OspLog(SYS_LOG_LEVEL,"[SignInCmd]not connected\n");
                return;
        }

        if(!pMsg->content || pMsg->length <= 0){
                OspLog(LOG_LVL_ERROR,"[SignInCmd] pMsg content is NULL\n");
                return;
        }
        if(m_bSignFlag){
                OspLog(SYS_LOG_LEVEL,"[SignInCmd]sign in already\n");
                return;
        }
        if(post(MAKEIID(SERVER_APP_ID,CInstance::DAEMON),SIGN_IN
                    ,pMsg->content,pMsg->length,g_dwdstNode) != OSP_OK){
                OspLog(LOG_LVL_ERROR,"[SignInCmd] post error\n");
                return;
        }
}

void CCInstance::SignInAck(CMessage * const pMsg){

        int i;

#if MULTY_APP
        if(!m_bConnectedFlag){
#else
        if(!g_bConnectedFlag){
#endif
                OspLog(LOG_LVL_ERROR,"[SignInAck]disconnected\n");
                return;
        }

        if(pMsg->length <= 0 || !pMsg->content){
                OspLog(SYS_LOG_LEVEL,"[SignInAck]sign in failed\n");
                printf("[SignInAck]sign in failed\n");
                return;
                //TODO:向GUI发送重新登陆提示
        }
        if(strcmp((LPCSTR)pMsg->content,"failed") == 0){
                OspLog(SYS_LOG_LEVEL,"[SignInAck]sign in failed\n");
                printf("[SignInAck]sign in failed\n");
                return;
                //TODO:向GUI发送重新登陆提示
        }

#if MULTY_APP
        //通知登陆
        for(i = 0;i < CLIENT_APP_SUM;i++){
                if(post(MAKEIID(i+CLIENT_APP_ID,CInstance::DAEMON),MY_SIGNED),NULL,0){
                        OspLog(LOG_LVL_ERROR,"[SignInAck] post error\n");
                        //TODO:错误处理
                        return;
                }
        }
#else
        g_bSignFlag = true
#endif
        OspLog(SYS_LOG_LEVEL,"[SignInAck]sign in successfully\n");
        printf("[SignInAck]sign in successfully\n");
}

void CCInstance::SignOutCmd(CMessage * const pMsg){

#if 0
        if(!m_bConnectedFlag){
                OspLog(LOG_LVL_ERROR,"[SignOutCmd]disconnected\n");
                return;
        }
#endif

        if(!m_bSignFlag){
                OspLog(SYS_LOG_LEVEL,"[SignOutCmd]haven't sign in\n");
                return;
        }

#if 0
        //TODO:查询所有App instance状态，需要线程锁
        //未处理完状态，重新放入消息队列等待状态稳定
        if(emFileStatus >= STATUS_SEND_UPLOAD&&
                        emFileStatus <= STATUS_RECEIVE_REMOVE){
                if(OSP_OK != post(MAKEIID(GetAppID(),GetInsID()),SIGN_OUT_CMD
                               ,NULL,0)){
                        OspLog(LOG_LVL_ERROR,"[SignOutCmd] post error\n");
                }
                return;
        }

        if(emFileStatus == STATUS_UPLOADING){
                //TODO:返回让用户选择remove或者cancel
                //暂时默认remove
                if(OSP_OK != post(MAKEIID(GetAppID(),)
                                        ,SEND_REMOVE_CMD,NULL,0,g_dwdstNode)){
                        OspLog(LOG_LVL_ERROR,"[SignOutCmd] post error\n");
                        return;
                }
        }

#endif

        if(OSP_OK != post(MAKEIID(SERVER_APP_ID,CInstance::DAEMON)
                                ,SIGN_OUT,NULL,0,g_dwdstNode)){
                OspLog(LOG_LVL_ERROR,"[SignOutCmd] post error\n");
                return;
        }
        OspLog(SYS_LOG_LEVEL,"get sign out cmd,send to server\n");
        OspPrintf(1,1,"get sign out cmd,send to server\n");

}

void CCInstance::SignOutAck(CMessage * const pMsg){

        int i;

#if MULTY_APP
        if(!m_bConnectedFlag){
#else
        if(!g_bConnectedFlag){
#endif
                OspLog(LOG_LVL_ERROR,"[SignOutAck]disconnected\n");
                return;
        }

#if MULTY_APP
          //通知登出
        for(i = 0;i < CLIENT_APP_SUM;i++){
                if(post(MAKEIID(i+CLIENT_APP_ID,CInstance::DAEMON),MY_DISSIGNED),NULL,0){
                        OspLog(LOG_LVL_ERROR,"[SignOutAck] post error\n");
                        //TODO:错误处理
                        return;
                }
        }
#else
        g_bSignFlag = false;
#endif
        OspLog(SYS_LOG_LEVEL,"[SignOutAck]sign out\n");
        printf("[SignOutAck]get sign out ack\n");
}

void CCInstance::FileReceiveUploadAck(CMessage * const pMsg){

        size_t buffer_size;

        if(!m_bSignFlag){
                OspLog(SYS_LOG_LEVEL,"[FileReceiveUploadAck]sign out\n");
                return;
        }

        m_dwDisInsID = pMsg->srcid;

        buffer_size = fread(buffer,1,sizeof(s8)*BUFFER_SIZE,file);
        if(ferror(file)){
                if(fclose(file) == 0){
                        OspLog(SYS_LOG_LEVEL,"[FileReceiveUploadAck]file closed\n");
                        file = NULL;
                }else{
                        OspLog(LOG_LVL_ERROR,"[FileReceiveUploadAck]file close failed\n");
                }
                //TODO:通知server关闭文件
                OspLog(LOG_LVL_ERROR,"[FileReceiveUploadAck] read-file error\n");
                return;
        }
        if(feof(file)){//文件已读取完毕，终止
             if(OSP_OK != post(pMsg->srcid,FILE_FINISH
                           ,buffer,buffer_size,g_dwdstNode)){
                  OspLog(LOG_LVL_ERROR,"[FileReceiveUploadAck]FILE_FINISH post error\n");
                  return;
             }
        
        }else{
             if(OSP_OK != post(pMsg->srcid,FILE_UPLOAD
                           ,buffer,buffer_size,g_dwdstNode)){
                  OspLog(LOG_LVL_ERROR,"[FileReceiveUploadAck]FILE_UPLOAD post error\n");
                  return;
             }
        }
        m_wUploadFileSize += buffer_size;
        printf("upload file rate:%f\n",(float)m_wUploadFileSize/(float)m_wFileSize);
}

void CCInstance::FileUploadAck(CMessage* const pMsg){

        size_t buffer_size;

        if(!m_bSignFlag){
                OspLog(LOG_LVL_ERROR,"[FileUploadAck]sign out\n");
                return;
        }

        if(!pMsg->content || pMsg->length <= 0){
                 OspLog(LOG_LVL_ERROR,"[FileUploadAck] pMsg content is NULL\n");
                 return;
        }

        emFileStatus = *((EM_FILE_STATUS*)pMsg->content);
//        memcpy((void*)emFileStatus,(const void*)pMsg->content,pMsg->length);
        if(emFileStatus == STATUS_UPLOADING){//继续发送
                buffer_size = fread(buffer,1,sizeof(s8)*BUFFER_SIZE,file);
                if(ferror(file)){
                        if(fclose(file) == 0){
                                OspLog(SYS_LOG_LEVEL,"[FileUploadAck]file closed\n");
                                file = NULL;
                        }else{
                                OspLog(LOG_LVL_ERROR,"[FileUploadAck]file close failed\n");
                        }
                        OspLog(LOG_LVL_ERROR,"[FileUploadAck] read-file error\n");
                        return;
                }
                if(feof(file)){//文件已读取完毕，终止
                     if(OSP_OK != post(pMsg->srcid,FILE_FINISH
                                   ,buffer,buffer_size,g_dwdstNode)){
                          OspLog(LOG_LVL_ERROR,"[FileUploadAck]FILE_FINISH post error\n");
                     }
           
                }else{//继续发送
                     if(OSP_OK != post(pMsg->srcid,FILE_UPLOAD
                                   ,buffer,buffer_size,g_dwdstNode)){
                          OspLog(LOG_LVL_ERROR,"[FileUploadAck]FILE_UPLOAD post error\n");
                     }
                }
                m_wUploadFileSize += buffer_size;
                printf("upload file rate:%f\n",(float)m_wUploadFileSize/(float)m_wFileSize);
        }else if(emFileStatus == STATUS_RECEIVE_CANCEL){//暂停
                if(OSP_OK != post(pMsg->srcid,FILE_CANCEL
                              ,NULL,0,g_dwdstNode)){
                     OspLog(LOG_LVL_ERROR,"[FileUploadAck]FILE_CANCEL post error\n");
                     return;
                }
        }else if(emFileStatus == STATUS_RECEIVE_REMOVE){//删除文件
                if(OSP_OK != post(pMsg->srcid,FILE_REMOVE
                              ,NULL,0,g_dwdstNode)){
                     OspLog(LOG_LVL_ERROR,"[FileUploadAck]FILE_REMOVE post error\n");
                     return;
                }
        }else{
                OspLog(LOG_LVL_ERROR,"[FileUploadAck]get incorrect file status\n");
                printf("[FileUploadAck]get incorrect file status\n");
        }
}

void CCInstance::FileFinishAck(CMessage* const pMsg){
        
        if(fclose(file) == 0){
                file = NULL;
                OspLog(SYS_LOG_LEVEL,"[FileFinishAck]file closed\n");

        }else{
                OspLog(LOG_LVL_ERROR,"[FileFinishAck]file close failed\n");
                return;
        }

        OspLog(SYS_LOG_LEVEL,"file upload finish\n");
        emFileStatus = STATUS_FINISHED;
        NextState(IDLE_STATE);
        m_wFileSize = 0;
        m_wUploadFileSize = 0;
}

void CCInstance::MsgProcessInit(){

        //Daemon Instance
        RegMsgProFun(MAKEESTATE(IDLE_STATE,SIGN_IN_CMD),&CCInstance::SignInCmd,&m_tCmdDaemonChain);
        RegMsgProFun(MAKEESTATE(IDLE_STATE,SIGN_OUT_CMD),&CCInstance::SignOutCmd,&m_tCmdDaemonChain);

        RegMsgProFun(MAKEESTATE(IDLE_STATE,SIGN_OUT_ACK),&CCInstance::SignOutAck,&m_tCmdDaemonChain);
        RegMsgProFun(MAKEESTATE(IDLE_STATE,SIGN_IN_ACK),&CCInstance::SignInAck,&m_tCmdDaemonChain);

        RegMsgProFun(MAKEESTATE(IDLE_STATE,OSP_DISCONNECT),&CCInstance::notifyDisconnect,&m_tCmdDaemonChain);
        RegMsgProFun(MAKEESTATE(IDLE_STATE,FILE_UPLOAD_CMD),&CCInstance::FileUploadCmd,&m_tCmdChain);
#if MULTY_APP
        RegMsgProFun(MAKEESTATE(IDLE_STATE,MY_CONNECT),&CCInstance::notifyConnect,&m_tCmdDaemonChain);
        RegMsgProFun(MAKEESTATE(IDLE_STATE,MY_SIGNED),&CCInstance::notifySigned,&m_tCmdDaemonChain);
        RegMsgProFun(MAKEESTATE(IDLE_STATE,MY_DISSIGNED),&CCInstance::notifyDissigned,&m_tCmdDaemonChain);
#endif


        //common Instance
        RegMsgProFun(MAKEESTATE(RUNNING_STATE,SEND_REMOVE_CMD),&CCInstance::RemoveCmd,&m_tCmdChain);
        RegMsgProFun(MAKEESTATE(IDLE_STATE,SEND_REMOVE_CMD),&CCInstance::RemoveCmd,&m_tCmdChain);
        RegMsgProFun(MAKEESTATE(RUNNING_STATE,SEND_CANCEL_CMD),&CCInstance::CancelCmd,&m_tCmdChain);
        RegMsgProFun(MAKEESTATE(RUNNING_STATE,FILE_GO_ON_CMD),&CCInstance::FileGoOnCmd,&m_tCmdChain);

        RegMsgProFun(MAKEESTATE(RUNNING_STATE,FILE_UPLOAD_ACK),&CCInstance::FileUploadAck,&m_tCmdChain);
        RegMsgProFun(MAKEESTATE(RUNNING_STATE,FILE_FINISH_ACK),&CCInstance::FileFinishAck,&m_tCmdChain);
        RegMsgProFun(MAKEESTATE(RUNNING_STATE,FILE_CANCEL_ACK),&CCInstance::FileCancelAck,&m_tCmdChain);
        RegMsgProFun(MAKEESTATE(RUNNING_STATE,FILE_REMOVE_ACK),&CCInstance::FileRemoveAck,&m_tCmdChain);
        RegMsgProFun(MAKEESTATE(RUNNING_STATE,FILE_GO_ON_ACK),&CCInstance::FileGoOnAck,&m_tCmdChain);
        RegMsgProFun(MAKEESTATE(RUNNING_STATE,FILE_RECEIVE_UPLOAD_ACK),&CCInstance::FileReceiveUploadAck
                        ,&m_tCmdChain);
        RegMsgProFun(MAKEESTATE(RUNNING_STATE,FILE_STABLE_REMOVE_ACK),&CCInstance::FileStableRemoveAck,
                        &m_tCmdChain);

#if MULTY_APP
        RegMsgProFun(MAKEESTATE(IDLE_STATE,FILE_UPLOAD_CMD),&CCInstance::FileUploadCmd,&m_tCmdChain);
        RegMsgProFun(MAKEESTATE(IDLE_STATE,GET_MY_CONNECT),&CCInstance::GetMyConnect,&m_tCmdChain);
        RegMsgProFun(MAKEESTATE(IDLE_STATE,GET_SIGNED),&CCInstance::GetSigned,&m_tCmdChain);
        RegMsgProFun(MAKEESTATE(IDLE_STATE,GET_DISSIGNED),&CCInstance::GetDissigned,&m_tCmdChain);
        RegMsgProFun(MAKEESTATE(IDLE_STATE,GET_DISCONNECT),&CCInstance::GetDisconnect,&m_tCmdChain);
#endif


        //直接返回不处理，调试信息完整，避免只返回can not find the EState
        RegMsgProFun(MAKEESTATE(IDLE_STATE,SEND_CANCEL_CMD),&CCInstance::CancelCmd,&m_tCmdChain);
        RegMsgProFun(MAKEESTATE(IDLE_STATE,FILE_GO_ON_CMD),&CCInstance::FileGoOnCmd,&m_tCmdChain);

}

void CCInstance::NodeChainEnd(){

        while(m_tCmdChain){
                free(m_tCmdChain);
                m_tCmdChain = m_tCmdChain->next;
        }

        while(m_tCmdDaemonChain){
                free(m_tCmdDaemonChain);
                m_tCmdDaemonChain = m_tCmdDaemonChain->next;
        }
}

bool CCInstance::RegMsgProFun(u32 EventState,MsgProcess c_MsgProcess,tCmdNode** tppNodeChain){

        tCmdNode *Node,*NewNode,*LNode;

        Node = *tppNodeChain;

        if(!(NewNode = (tCmdNode*)malloc(sizeof(tCmdNode)))){
                OspLog(LOG_LVL_ERROR,"[RegMsgProFun] node malloc error\n");
                return false;
        }

        NewNode->EventState = EventState;
        NewNode->c_MsgProcess = c_MsgProcess;
        NewNode->next = NULL;

        if(!Node){
                *tppNodeChain = NewNode;
                OspLog(SYS_LOG_LEVEL,"cmd chain init \n");
                return true;
        }

        while(Node){
                if(Node->EventState == EventState){
                        OspLog(LOG_LVL_ERROR,"[RegMsgProFun] node already in \n");
                        printf("[RegMsgProFun] node already in \n");
                        return false;
                }
                LNode = Node;
                Node = Node->next;
        }
        LNode->next = NewNode;

        return true;
}

bool CCInstance::FindProcess(u32 EventState,MsgProcess* c_MsgProcess,tCmdNode* tNodeChain){

        tCmdNode *Node;

        Node = tNodeChain;
        if(!Node){
                OspLog(LOG_LVL_ERROR,"[FindProcess] Node Chain is NULL\n");
                printf("[FindProcess] Node Chain is NULL\n");
                return false;
        }
        while(Node){

                if(Node->EventState == EventState){
                        *c_MsgProcess = Node->c_MsgProcess;
                        return true;
                }
                Node = Node->next;
        }

        return false;
}

void CCInstance::InstanceEntry(CMessage * const pMsg){

        u32 curState = CurState();
        u16 curEvent = pMsg->event;
        MsgProcess c_MsgProcess;

#if 0
        if(!m_bConnectedFlag){
                OspLog(LOG_LVL_ERROR,"[InstanceEntry]disconnected\n");
                return;
        }
        if(!m_bSignFlag){
                OspLog(SYS_LOG_LEVEL,"[FileReceiveUploadAck]sign out\n");
                return;
        }
#endif

        if(NULL == pMsg){
                OspLog(LOG_LVL_ERROR,"[InstanceEntry] pMsg is NULL\n");
                return;
        }

        if(FindProcess(MAKEESTATE(curState,curEvent),&c_MsgProcess,m_tCmdChain)){
                (this->*c_MsgProcess)(pMsg);
        }else{
                OspLog(LOG_LVL_ERROR,"[InstanceEntry] can not find the EState,event:%d\nstate:%d\n"
                                ,curEvent,curState);
                printf("[InstanceEntry] can not find the EState\n");
        }

}

void CCInstance::DaemonInstanceEntry(CMessage *const pMsg,CApp *pCApp){

        u32 curState = CurState();
        u16 curEvent = pMsg->event;
        MsgProcess c_MsgProcess;

        if(NULL == pMsg){
                OspLog(LOG_LVL_ERROR,"[DaemonInstanceEntry] pMsg is NULL\n");
                return;
        }

        if(FindProcess(MAKEESTATE(curState,curEvent),&c_MsgProcess,m_tCmdDaemonChain)){
                (this->*c_MsgProcess)(pMsg);
        }else{
                OspLog(LOG_LVL_ERROR,"[DaemonInstanceEntry] can not find the EState\n");
                printf("[DaemonInstanceEntry] can not find the EState\n");
        }
}

void CCInstance::RemoveCmd(CMessage* const pMsg){


        //从GUI的使用来说，这个可以保证
        if(emFileStatus == STATUS_INIT){
                OspLog(LOG_LVL_ERROR,"[RemoveCmd]status error\n");
                return;
        }
        //未处理完状态，重新放入消息队列等待状态稳定
        if(emFileStatus >= STATUS_SEND_UPLOAD&&
                        emFileStatus <= STATUS_RECEIVE_REMOVE){
                if(OSP_OK != post(MAKEIID(GetAppID(),GetInsID()),SEND_REMOVE_CMD
                               ,NULL,0)){
                        OspLog(LOG_LVL_ERROR,"[RemoveCmd] post error\n");
                }
                return;
        }

        if(emFileStatus == STATUS_REMOVED){
                OspLog(SYS_LOG_LEVEL,"[RemoveCmd]Already removed\n");
                return;
        }

        if(emFileStatus == STATUS_CANCELLED || emFileStatus == STATUS_FINISHED){
                if(OSP_OK != post(m_dwDisInsID,FILE_STABLE_REMOVE
                               ,NULL,0,g_dwdstNode)){
                        OspLog(LOG_LVL_ERROR,"[RemoveCmd] post error\n");
                }
                return;
        }

        if(OSP_OK != post(m_dwDisInsID,SEND_REMOVE
                       ,NULL,0,g_dwdstNode)){
                OspLog(LOG_LVL_ERROR,"[RemoveCmd] post error\n");
                return;
        }
        emFileStatus = STATUS_SEND_REMOVE;
}

void CCInstance::FileGoOnCmd(CMessage* const pMsg){

        //未处理完状态，重新放入消息队列等待状态稳定
        if(emFileStatus >= STATUS_SEND_UPLOAD&&
                        emFileStatus <= STATUS_RECEIVE_REMOVE){
                if(OSP_OK != post(MAKEIID(GetAppID(),GetInsID()),FILE_GO_ON_CMD
                               ,NULL,0)){
                        OspLog(LOG_LVL_ERROR,"[RemoveCmd] post error\n");
                }
                return;
        }
        
        //从GUI的使用来说，这个可以保证
        if(emFileStatus == STATUS_INIT){
                OspLog(LOG_LVL_ERROR,"[FileGoOnCmd]status error,upload first\n");
                return;
        }

        if(emFileStatus == STATUS_FINISHED 
                        || emFileStatus == STATUS_REMOVED){
                OspLog(SYS_LOG_LEVEL,"file already finished or removed\n");
                return;
        }

        if(emFileStatus == STATUS_UPLOADING){
                OspLog(SYS_LOG_LEVEL,"Already go on\n");
                return;
        }

        if(OSP_OK != post(m_dwDisInsID,FILE_GO_ON
                       ,NULL,0,g_dwdstNode)){
                OspLog(LOG_LVL_ERROR,"[FileGoOnCmd]file go on post error\n");
                return;
        }
        emFileStatus = STATUS_SEND_UPLOAD;
}

void CCInstance::FileGoOnAck(CMessage* const pMsg){

        if(!(file = fopen((LPCSTR)file_name_path,"rb"))){
                OspLog(LOG_LVL_ERROR,"[FileGoOnAck]open file failed\n");
                printf("[FileGoOnAck]open file failed\n");
                return;
        }

        if(fseek(file,m_wUploadFileSize,SEEK_SET) != 0){
                 OspLog(LOG_LVL_ERROR,"[FileGoOnAck] file fseeek error\n");
                 return;
        }

        FileReceiveUploadAck(pMsg);
}

void CCInstance::CancelCmd(CMessage* const pMsg){

        //从GUI的使用来说，这个可以保证
        if(emFileStatus == STATUS_INIT){
                OspLog(LOG_LVL_ERROR,"[CancelCmd]status error\n");
                return;
        }

        //未处理完状态，重新放入消息队列等待状态稳定
        if(emFileStatus >= STATUS_SEND_UPLOAD&&
                        emFileStatus <= STATUS_RECEIVE_REMOVE){
                if(OSP_OK != post(MAKEIID(GetAppID(),GetInsID()),SEND_CANCEL_CMD
                               ,NULL,0)){
                        OspLog(LOG_LVL_ERROR,"[CancelCmd] post error\n");
                }
                return;
        }

        if(emFileStatus >= STATUS_CANCELLED){
                OspLog(SYS_LOG_LEVEL,"[CancelCmd]Already stable state\n");
                return;
                
        }

        if(OSP_OK != post(m_dwDisInsID,SEND_CANCEL
                       ,NULL,0,g_dwdstNode)){
                OspLog(LOG_LVL_ERROR,"[CancelCmd] post error\n");
                return;
        }
        emFileStatus = STATUS_SEND_CANCEL;
}

void CCInstance::FileCancelAck(CMessage* const pMsg){

        u16 wAppId;

        if(fclose(file) == 0){
                OspLog(SYS_LOG_LEVEL,"[FileCancelAck]file closed\n");
                file = NULL;
        }else{
                OspLog(LOG_LVL_ERROR,"[FileCancelAck]file close failed\n");
                return;
        }
        emFileStatus = STATUS_CANCELLED;
}

void CCInstance::FileRemoveAck(CMessage* const pMsg){

        if(fclose(file) == 0){
                OspLog(SYS_LOG_LEVEL,"[FileRemovelAck]file closed\n");
                file = NULL;
        }else{
                OspLog(LOG_LVL_ERROR,"[FileRemoveAck]file close failed\n");
                return;
        }
        emFileStatus = STATUS_REMOVED;
        m_wUploadFileSize = 0;
        m_wFileSize = 0;
        NextState(IDLE_STATE);
        //TODO:key print
        printf("file remove\n");
}

void CCInstance::FileStableRemoveAck(CMessage* const pMsg){

        emFileStatus = STATUS_REMOVED;
        m_wUploadFileSize = 0;
        m_wFileSize = 0;
        NextState(IDLE_STATE);
        //TODO:key print
        printf("file remove\n");
}

void CCInstance::notifyDisconnect(CMessage* const pMsg){

        //TODO:断开之后状态需要回收

#if MULTY_APP
        m_bConnectedFlag = false;
        m_bSignFlag = false;

        if(OSP_OK != post(MAKEIID(GetAppID(),CLIENT_INSTANCE_ID),GET_DISCONNECT
                       ,NULL,0)){
                OspLog(LOG_LVL_ERROR,"[notifyDisConnect] post error\n");
        }
#else
        g_bConnectedFlag = false;
        g_bSignFlag = false;
#endif
}

#if MULTY_APP

void CCInstance::GetDisconnect(CMessage* const pMsg){

        //TODO:断开之后状态需要回收
        m_bConnectedFlag = false;
        m_bSignFlag = false;

        //TODO：断点续传
        if(file){
                if(fclose(file) == 0){
                        OspLog(SYS_LOG_LEVEL,"[FileRemovelAck]file closed\n");
                        file = NULL;
                }else{
                        OspLog(LOG_LVL_ERROR,"[FileRemoveAck]file close failed\n");
                        return;
                }
        }
        //需要配合文件的关闭回收
        emFileStatus = STATUS_INIT;
        NextState(IDLE_STATE);
        m_dwDisInsID = 0;
        m_wFileSize = 0;
        m_wUploadFileSize = 0;
        //m_wServerPort = SERVER_PORT;
        OspLog(SYS_LOG_LEVEL,"[GetDisconnect]disconnected\n");
}

void CCInstance::notifyConnect(CMessage* const pMsg){

        m_bConnectedFlag = true;
        if(OSP_OK != post(MAKEIID(GetAppID(),CLIENT_INSTANCE_ID),GET_MY_CONNECT
                       ,NULL,0)){
                OspLog(LOG_LVL_ERROR,"[notifyConnect] post error\n");
        }
}

void CCInstance::GetMyConnect(CMessage* const pMsg){

        m_bConnectedFlag = true;
        OspLog(SYS_LOG_LEVEL,"[GetMyConnect]server connected\n");
}


void CCInstance::notifySigned(CMessage* const pMsg){

        m_bSignFlag = true;
        if(OSP_OK != post(MAKEIID(GetAppID(),CLIENT_INSTANCE_ID),GET_SIGNED
                       ,NULL,0)){
                OspLog(LOG_LVL_ERROR,"[notifySigned] post error\n");
        }

        OspLog(SYS_LOG_LEVEL,"[notifySigned]sign in\n");
}

void CCInstance::GetSigned(CMessage* const pMsg){

        m_bSignFlag = true;
}

void CCInstance::GetDissigned(CMessage* const pMsg){

        m_bSignFlag = false;
}

void CCInstance::notifyDissigned(CMessage* const pMsg){

        m_bSignFlag = false;
        if(OSP_OK != post(MAKEIID(GetAppID(),CLIENT_INSTANCE_ID),GET_DISSIGNED
                       ,NULL,0)){
                OspLog(LOG_LVL_ERROR,"[notifyDissigned] post error\n");
        }

        OspLog(SYS_LOG_LEVEL,"[notifyDissigned]sign out\n");
}
#endif
